spool C:\Users\circl\Documents\2023-2\database_programming\week2\oracle_week2.txt;
/*Q1 : 1NF -> 2NF*/
DROP TABLE STUDENT_GRADE CASCADE CONSTRAINTS PURGE;
DROP TABLE STUDENT_SCORE_2NF CASCADE CONSTRAINTS PURGE;
DROP TABLE STUDENT_CLASS_2NF CASCADE CONSTRAINTS PURGE;

CREATE TABLE STUDENT_GRADE(
     Sid VARCHAR(10) NOT NULL,
     Cid VARCHAR(10) NOT NULL,
     Score NUMBER(4),
     Grade VARCHAR(5),
     Cname VARCHAR(15),
     Cunit VARCHAR(2),
     PRIMARY KEY(Sid, Cid));

INSERT INTO STUDENT_GRADE VALUES('2016127059','C100',95,'A','CLanguage','3');
INSERT INTO STUDENT_GRADE VALUES('2016127060','C200',81,'B','Database','3');
INSERT INTO STUDENT_GRADE VALUES('2016127061','C200',84,'B','Database','3');
INSERT INTO STUDENT_GRADE VALUES('2016127062','C300',70,'C','Programing','3');

CREATE TABLE STUDENT_CLASS_2NF(
    Cid VARCHAR(10) NOT NULL,
    Cname VARCHAR(15),
    Cunit VARCHAR(2),
    PRIMARY KEY(Cid)
);

INSERT INTO STUDENT_CLASS_2NF VALUES('C100', 'CLanguage', '3');
INSERT INTO STUDENT_CLASS_2NF VALUES('C200', 'Database', '3');
INSERT INTO STUDENT_CLASS_2NF VALUES('C300', 'Programing', '3');

CREATE TABLE STUDENT_SCORE_2NF(
    Sid VARCHAR(10) NOT NULL,
    Cid VARCHAR(10) NOT NULL,
    Score NUMBER(4),
    Grade VARCHAR(5),
    PRIMARY KEY(Sid, Cid)
);

INSERT INTO STUDENT_SCORE_2NF VALUES('2016127059','C100',95,'A');
INSERT INTO STUDENT_SCORE_2NF VALUES('2016127060','C200',81,'B');
INSERT INTO STUDENT_SCORE_2NF VALUES('2016127061','C200',84,'B');
INSERT INTO STUDENT_SCORE_2NF VALUES('2016127062','C300',70,'C');

COMMIT;

-- 변환 결과
SELECT * FROM STUDENT_GRADE;
SELECT * FROM STUDENT_CLASS_2NF;
SELECT * FROM STUDENT_SCORE_2NF;

-- 참조 무결성 확인 
SELECT Cid
FROM STUDENT_SCORE_2NF
WHERE Cid NOT IN (
    SELECT STUDENT_SCORE_2NF.Cid
    FROM STUDENT_SCORE_2NF, STUDENT_CLASS_2NF
    WHERE STUDENT_SCORE_2NF.Cid = STUDENT_CLASS_2NF.Cid
);

-- 변환 전후
SELECT Sid, Cid, Score, Grade, Cname, Cunit
FROM STUDENT_SCORE_2NF NATURAL JOIN STUDENT_CLASS_2NF
ORDER BY Sid asc, Cid desc;
SELECT * FROM STUDENT_GRADE;

/* 변환 타당성 
2NF는 1NF를 만족하고 부분 함수 종속이 없어야 한다. 
하지만 STUDENT_GRADE에서 Cname과 Cunit이 Cid에만 종속되어 있다.
따라서 
STUDENT_SCORE_2NF(Sid, Cid, Score, Grade),
STUDENT_CLASS_2NF(Cid, Cname, Cunit)
의 두 릴레이션으로 분리하여 2NF를 만족하게 하였다. 
*/

/*Q2 : 2NF -> 3NF*/
DROP TABLE STUDENT_INFO_1 CASCADE CONSTRAINTS PURGE; 
DROP TABLE STUDENT_MAJOR_3NF CASCADE CONSTRAINTS PURGE; 
DROP TABLE STUDENT_PERSONAL_3NF CASCADE CONSTRAINTS PURGE; 

CREATE TABLE STUDENT_INFO_1(
     Sid VARCHAR(10) NOT NULL,
     Sname VARCHAR(25),
     Phone VARCHAR(25),
     Mid VARCHAR(5),
     Mname VARCHAR(25),
     PRIMARY KEY(Sid));

INSERT INTO STUDENT_INFO_1 VALUES('2018121001','James','010-1234-5678','C1041','ComputerScience');
INSERT INTO STUDENT_INFO_1 VALUES('2018121002','Michael','010-8765-4321','C1041','ComputerScience');
INSERT INTO STUDENT_INFO_1 VALUES('2018121003','Lisa','010-4433-2211','A2004','ArtificialIntelligence');
INSERT INTO STUDENT_INFO_1 VALUES('2018121004','Carol','010-9876-5555','A2004','ArtificialIntelligence');

CREATE TABLE STUDENT_MAJOR_3NF(
    Mid VARCHAR(5) NOT NULL,
    Mname VARCHAR(25),
    PRIMARY KEY(Mid)
);

CREATE TABLE STUDENT_PERSONAL_3NF(
    Sid VARCHAR(10) NOT NULL,
    Sname VARCHAR(25),
    Phone VARCHAR(25),
    Mid VARCHAR(5),
    PRIMARY KEY(Sid),
    FOREIGN KEY (Mid) REFERENCES STUDENT_MAJOR(Mid)
);

INSERT INTO STUDENT_MAJOR_3NF VALUES('C1041','ComputerScience');
INSERT INTO STUDENT_MAJOR_3NF VALUES('A2004','ArtificialIntelligence');

INSERT INTO STUDENT_PERSONAL_3NF VALUES('2018121001','James','010-1234-5678','C1041');
INSERT INTO STUDENT_PERSONAL_3NF VALUES('2018121002','Michael','010-8765-4321','C1041');
INSERT INTO STUDENT_PERSONAL_3NF VALUES('2018121003','Lisa','010-4433-2211','A2004');
INSERT INTO STUDENT_PERSONAL_3NF VALUES('2018121004','Carol','010-9876-5555','A2004');

COMMIT;

-- 변환 결과
SELECT * FROM STUDENT_INFO_1;
SELECT * FROM STUDENT_MAJOR_3NF;
SELECT * FROM STUDENT_PERSONAL_3NF;

-- 참조 무결성 확인
SELECT Mid FROM STUDENT_PERSONAL_3NF
WHERE Mid NOT IN (
    SELECT STUDENT_PERSONAL_3NF.Mid
    FROM STUDENT_PERSONAL_3NF, STUDENT_MAJOR_3NF
    WHERE STUDENT_PERSONAL_3NF.Mid = STUDENT_MAJOR_3NF.Mid
);

-- 변환 전후 
SELECT Sid, Sname, Phone, Mid, Mname
FROM STUDENT_PERSONAL_3NF NATURAL JOIN STUDENT_MAJOR_3NF
ORDER BY Sid;
SELECT * FROM STUDENT_INFO_1;

/* 변환 타당성
3NF는 2NF를 만족하고 이행 함수 종속이 없어야 한다. 
하지만 STUDENT_INFO_1에서 FD2를 보면 Mname은 Mid에만 종속되어 있다. 
따라서 이를 없애기 위해 
STUDENT_MAJOR_3NF(Mid, Mname)
STUDENT_PERSONAL_3NF(Sid, Sname, Phone, Mid)
로 나누어 3NF를 만족하게 하였다.
*/

/*Q3 : 3NF -> BCNF*/
DROP TABLE PROJECT_INFO CASCADE CONSTRAINTS PURGE; 
DROP TABLE PROJECT_DEPARTMENT_BCNF CASCADE CONSTRAINTS PURGE; 
DROP TABLE PROJECT_PROJECT_BCNF CASCADE CONSTRAINTS PURGE; 

CREATE TABLE PROJECT_INFO(
     Pname VARCHAR(25) NOT NULL,
     Dname VARCHAR(25) NOT NULL,
     Manager VARCHAR(25) NOT NULL,
     PRIMARY KEY(Pname, Dname));

INSERT INTO PROJECT_INFO VALUES('SchoolProject','Management','Michelle');
INSERT INTO PROJECT_INFO VALUES('ProgrammingProject','Development','Sarah');
INSERT INTO PROJECT_INFO VALUES('RobotProject', 'MachineryDivision', 'Ruth');
INSERT INTO PROJECT_INFO VALUES('RobotProject', 'TechnicalSupport', 'Donna');

CREATE TABLE PROJECT_PROJECT_BCNF(
    Manager VARCHAR(25) NOT NULL,
    Pname VARCHAR(25) NOT NULL,
    PRIMARY KEY(Manager)
);

CREATE TABLE PROJECT_DEPARTMENT_BCNF(
    Pname VARCHAR(25) NOT NULL,
    Dname VARCHAR(25) NOT NULL,
    Manager VARCHAR(25) NOT NULL,
    PRIMARY KEY(Pname, Dname),
    FOREIGN KEY(Manager) REFERENCES PROJECT_PROJECT_BCNF(Manager)
);

INSERT INTO PROJECT_PROJECT_BCNF VALUES('Michelle', 'SchoolProject');
INSERT INTO PROJECT_PROJECT_BCNF VALUES('Sarah', 'ProgrammingProject');
INSERT INTO PROJECT_PROJECT_BCNF VALUES('Ruth', 'RobotProject');
INSERT INTO PROJECT_PROJECT_BCNF VALUES('Donna', 'RobotProject');

INSERT INTO PROJECT_DEPARTMENT_BCNF VALUES('SchoolProject','Management','Michelle');
INSERT INTO PROJECT_DEPARTMENT_BCNF VALUES('ProgrammingProject','Development','Sarah');
INSERT INTO PROJECT_DEPARTMENT_BCNF VALUES('RobotProject', 'MachineryDivision', 'Ruth');
INSERT INTO PROJECT_DEPARTMENT_BCNF VALUES('RobotProject', 'TechnicalSupport', 'Donna');

COMMIT;

-- 변환 결과
SELECT * FROM PROJECT_INFO;
SELECT * FROM PROJECT_DEPARTMENT_BCNF;
SELECT * FROM PROJECT_PROJECT_BCNF;

-- 참조 무결성 확인
SELECT Manager FROM PROJECT_DEPARTMENT_BCNF
WHERE Manager NOT IN (
    SELECT PROJECT_DEPARTMENT_BCNF.Manager
    FROM PROJECT_PROJECT_BCNF, PROJECT_DEPARTMENT_BCNF
    WHERE PROJECT_DEPARTMENT_BCNF.Manager = PROJECT_PROJECT_BCNF.Manager
);

-- 변환 전후 
SELECT Pname, Dname, Manager
FROM PROJECT_DEPARTMENT_BCNF NATURAL JOIN PROJECT_PROJECT_BCNF;
SELECT * FROM PROJECT_INFO;

/* 변환 타당성
BCNF는 3NF를 만족하면서 모든 attribute가 후보키이어야 한다. 
그러나 PROJECT_INFO의 FD2를 보면 Manager는 키가 아니지만 Pname에 대한 함수 종속성을 가진다. 
따라서 
PROJECT_DEPARTMENT_BCNF(Pname, Dname, Manager)
PROJECT_PROJECT_BCNF(Manager, Pname)
의 두 릴레이션으로 나누어 BCNF를 만족하게 하였다. 
*/

/*Q4 : BCNF -> 4NF*/
DROP TABLE STUDENT_INFO_2 CASCADE CONSTRAINTS PURGE; 
DROP TABLE STUDENT_CLUB_4NF CASCADE CONSTRAINTS PURGE;
DROP TABLE STUDENT_VOLUNTEER_4NF CASCADE CONSTRAINTS PURGE;

CREATE TABLE STUDENT_INFO_2(
     Sname VARCHAR(10) NOT NULL,
     Club VARCHAR(25) NOT NULL,
     Volunteer VARCHAR(25) NOT NULL,
     PRIMARY KEY(Sname, Club, Volunteer));

INSERT INTO STUDENT_INFO_2 VALUES('Chau','PhotographyClub','SeniorCenter');
INSERT INTO STUDENT_INFO_2 VALUES('Chau','BookClub','SeniorCenter');
INSERT INTO STUDENT_INFO_2 VALUES('Green','CookingClub','Orphanage');
INSERT INTO STUDENT_INFO_2 VALUES('Jones','MusicClub','HomelessShelter');
INSERT INTO STUDENT_INFO_2 VALUES('Jones','MusicClub','SeniorCenter');
INSERT INTO STUDENT_INFO_2 VALUES('Jones','DanceClub','HomelessShelter');
INSERT INTO STUDENT_INFO_2 VALUES('Jones','DanceClub','SeniorCenter');
INSERT INTO STUDENT_INFO_2 VALUES('Jones','BadmintonClub','HomelessShelter');
INSERT INTO STUDENT_INFO_2 VALUES('Jones','BadmintonClub','SeniorCenter');

CREATE TABLE STUDENT_CLUB_4NF(
    Sname VARCHAR(10) NOT NULL,
    Club VARCHAR(25) NOT NULL,
    PRIMARY KEY(Sname, Club)
);

CREATE TABLE STUDENT_VOLUNTEER_4NF(
     Sname VARCHAR(10) NOT NULL,
     Volunteer VARCHAR(25) NOT NULL,
     PRIMARY KEY(Sname, Volunteer)
);

INSERT INTO STUDENT_CLUB_4NF VALUES('Chau','PhotographyClub');
INSERT INTO STUDENT_CLUB_4NF VALUES('Chau','BookClub');
INSERT INTO STUDENT_CLUB_4NF VALUES('Green','CookingClub');
INSERT INTO STUDENT_CLUB_4NF VALUES('Jones','MusicClub');
INSERT INTO STUDENT_CLUB_4NF VALUES('Jones','DanceClub');
INSERT INTO STUDENT_CLUB_4NF VALUES('Jones','BadmintonClub');

INSERT INTO STUDENT_VOLUNTEER_4NF VALUES('Chau','SeniorCenter');
INSERT INTO STUDENT_VOLUNTEER_4NF VALUES('Green','Orphanage');
INSERT INTO STUDENT_VOLUNTEER_4NF VALUES('Jones','HomelessShelter');
INSERT INTO STUDENT_VOLUNTEER_4NF VALUES('Jones','SeniorCenter');

COMMIT;

-- 변환 결과
SELECT * FROM STUDENT_INFO_2;
SELECT * FROM STUDENT_CLUB_4NF;
SELECT * FROM STUDENT_VOLUNTEER_4NF;

-- 참조 무결성 확인
SELECT Sname FROM STUDENT_CLUB_4NF
WHERE Sname NOT IN (
    SELECT STUDENT_CLUB_4NF.Sname
    FROM STUDENT_CLUB_4NF, STUDENT_VOLUNTEER_4NF
    WHERE STUDENT_CLUB_4NF.Sname = STUDENT_VOLUNTEER_4NF.Sname
);

-- 변환 전후 
SELECT Sname, Club, Volunteer
FROM STUDENT_CLUB_4NF NATURAL JOIN STUDENT_VOLUNTEER_4NF
ORDER BY Club;
SELECT * FROM STUDENT_INFO_2;

/* 변환 타당성
4NF는 모든 attribute들이 super key이고, 어떤 attribute도 2개 이상의 다치 종속성을 가지면 안된다. 
하지만 STUDENT_INFO_2에서 Sname은 Club과 Volunteer에 대해 다치 종속성을 갖는다. 
따라서 
STUDENT_CLUB_4NF(Sname, Club)
STUDENT_VOLUNTEER_4NF(Sname, Volunteer)
의 2개의 릴레이션으로 나누어 4NF를 만족하게 하였다.  
*/

spool off;